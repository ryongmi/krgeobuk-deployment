// authz-server ì „ìš© ë°°í¬ íŒŒì´í”„ë¼ì¸
// ê¶Œí•œ ê´€ë¦¬ ì„œë²„ì˜ ë¹Œë“œ, í…ŒìŠ¤íŠ¸, ë°°í¬ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.

@Library('krgeobuk-shared-library') _

pipeline {
    agent any

    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'prod'],
            description: 'ë°°í¬ í™˜ê²½'
        )
        string(
            name: 'GIT_BRANCH',
            defaultValue: 'dev',
            description: 'Git ë¸Œëœì¹˜'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'í…ŒìŠ¤íŠ¸ ê±´ë„ˆë›°ê¸°'
        )
        booleanParam(
            name: 'RUN_E2E_TESTS',
            defaultValue: false,
            description: 'E2E í…ŒìŠ¤íŠ¸ ì‹¤í–‰'
        )
    }

    environment {
        SERVICE_NAME = 'authz-server'
        DOCKER_REGISTRY = 'krgeobuk'
        DOCKER_CREDENTIALS_ID = 'docker-registry-credentials'

        GIT_REPO = 'https://github.com/ryongmi/authz-server.git'
        GIT_CREDENTIALS_ID = 'github-credentials'

        BUILD_TIMESTAMP = sh(script: "date +%Y%m%d-%H%M%S", returnStdout: true).trim()
        GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()

        // ì´ë¯¸ì§€ íƒœê·¸: devëŠ” latest, prodëŠ” timestamp
        IMAGE_TAG = params.ENVIRONMENT == 'dev' ? 'latest' : "${BUILD_TIMESTAMP}-${GIT_COMMIT_SHORT}"

    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '30'))
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
    }

    // ============================================================================
    // GitHub Webhook ìë™ ë¹Œë“œ ì„¤ì • (ì£¼ì„ í•´ì œ í›„ ì‚¬ìš©)
    // ============================================================================
    // GitHubì—ì„œ push ë˜ëŠ” PR ì´ë²¤íŠ¸ ë°œìƒ ì‹œ ìë™ìœ¼ë¡œ ë¹Œë“œë¥¼ íŠ¸ë¦¬ê±°í•©ë‹ˆë‹¤.
    //
    // ì‚¬ìš© ë°©ë²•:
    // 1. Jenkins ì„¤ì •:
    //    - Jenkins > Manage Jenkins > Configure System
    //    - GitHub Server ì¶”ê°€ ë° Credentials ì„¤ì •
    //    - GitHub Plugin ì„¤ì¹˜ í™•ì¸
    //
    // 2. GitHub Webhook ì„¤ì •:
    //    - GitHub ë¦¬í¬ì§€í† ë¦¬ > Settings > Webhooks > Add webhook
    //    - Payload URL: http://your-jenkins-url/github-webhook/
    //    - Content type: application/json
    //    - Events: Push events, Pull requests
    //
    // 3. ì•„ë˜ ì£¼ì„ í•´ì œ:
    //    triggers ë¸”ë¡ì˜ ì£¼ì„ì„ ì œê±°í•˜ê³  ì‚¬ìš©
    //
    // ì£¼ì˜ì‚¬í•­:
    //    - Jenkinsê°€ ì¸í„°ë„·ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•´ì•¼ í•¨ (í¬íŠ¸ í¬ì›Œë”© ë˜ëŠ” ngrok ë“±)
    //    - GitHub Webhook Secret ì„¤ì • ê¶Œì¥ (ë³´ì•ˆ)
    // ============================================================================

    /*
    triggers {
        // GitHub webhookì„ í†µí•œ ìë™ ë¹Œë“œ
        githubPush()

        // ë˜ëŠ” íŠ¹ì • ë¸Œëœì¹˜ì— ëŒ€í•´ì„œë§Œ íŠ¸ë¦¬ê±° (ì„ íƒì‚¬í•­)
        // GenericTrigger(
        //     genericVariables: [
        //         [key: 'ref', value: '$.ref']
        //     ],
        //     causeString: 'Triggered by GitHub push',
        //     token: 'authz-server-webhook-token',
        //     printContributedVariables: true,
        //     printPostContent: true,
        //     regexpFilterText: '$ref',
        //     regexpFilterExpression: 'refs/heads/(dev|main)'
        // )
    }
    */

    stages {
        stage('ğŸ“‹ Prepare') {
            steps {
                script {
                    load("jenkins/config/${params.ENVIRONMENT}.groovy")
                    echo """
                    =========================================
                    authz-server ë°°í¬ íŒŒì´í”„ë¼ì¸
                    =========================================
                    í™˜ê²½: ${params.ENVIRONMENT}
                    ë¸Œëœì¹˜: ${params.GIT_BRANCH}
                    ë„¤ì„ìŠ¤í˜ì´ìŠ¤: ${env.K8S_NAMESPACE}
                    ì´ë¯¸ì§€ íƒœê·¸: ${env.IMAGE_TAG}
                    =========================================
                    """
                }
            }
        }

        stage('ğŸ” Checkout') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${params.GIT_BRANCH}"]],
                    userRemoteConfigs: [[
                        url: env.GIT_REPO,
                        credentialsId: env.GIT_CREDENTIALS_ID
                    ]]
                ])
            }
        }

        stage('ğŸ“¦ Install Dependencies') {
            steps {
                sh 'npm ci'
            }
        }

        stage('ğŸ§ª Run Tests') {
            when {
                expression { !params.SKIP_TESTS }
            }
            parallel {
                stage('Unit Tests') {
                    steps {
                        sh 'npm run test'
                    }
                }
                stage('Lint') {
                    steps {
                        sh 'npm run lint'
                    }
                }
            }
        }

        stage('ğŸ§ª E2E Tests') {
            when {
                expression { params.RUN_E2E_TESTS }
            }
            steps {
                sh 'npm run test:e2e'
            }
        }

        stage('ğŸ—ï¸ Build') {
            steps {
                sh 'npm run build'
            }
        }

        stage('ğŸ³ Build Docker Image') {
            steps {
                script {
                    if (params.ENVIRONMENT == 'dev') {
                        // dev í™˜ê²½: ë¡œì»¬ ì´ë¯¸ì§€ ë¹Œë“œ (miniPCì—ì„œ ì‚¬ìš©)
                        echo "Building local Docker image for dev environment..."
                        sh """
                            docker build -t ${env.SERVICE_NAME}:latest .
                            echo "âœ“ Local image built: ${env.SERVICE_NAME}:latest"
                        """
                    } else {
                        // prod í™˜ê²½: Registryì— push
                        echo "Building and pushing Docker image for prod environment..."
                        buildImage(
                            serviceName: env.SERVICE_NAME,
                            imageTag: env.IMAGE_TAG,
                            dockerRegistry: env.DOCKER_REGISTRY,
                            additionalTags: ['latest']
                        )
                    }
                }
            }
        }

        stage('ğŸš€ Deploy to Kubernetes') {
            steps {
                script {
                    if (env.MANUAL_APPROVAL.toBoolean()) {
                        input message: 'Production í™˜ê²½ì— ë°°í¬í•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
                              ok: 'Deploy to Production',
                              submitter: 'admin,devops'
                    }

                    deployToK8s(
                        environment: params.ENVIRONMENT,
                        service: env.SERVICE_NAME,
                        imageTag: env.IMAGE_TAG,
                        namespace: env.K8S_NAMESPACE
                    )
                }
            }
        }

        stage('âœ… Verify Deployment') {
            steps {
                sh """
                    kubectl rollout status deployment/${env.SERVICE_NAME} -n ${env.K8S_NAMESPACE} --timeout=5m
                    kubectl get pods -n ${env.K8S_NAMESPACE} -l app=${env.SERVICE_NAME}
                """
            }
        }

        stage('ğŸ” Health Check') {
            steps {
                sh """
                    kubectl wait --for=condition=ready pod -l app=${env.SERVICE_NAME} -n ${env.K8S_NAMESPACE} --timeout=300s

                    POD_NAME=\$(kubectl get pod -n ${env.K8S_NAMESPACE} -l app=${env.SERVICE_NAME} -o jsonpath='{.items[0].metadata.name}')
                    kubectl exec \$POD_NAME -n ${env.K8S_NAMESPACE} -- curl -f http://localhost:8100/health || exit 1
                """
            }
        }
    }

    post {
        success {
            script {
                notifySlack(
                    status: 'SUCCESS',
                    channel: env.SLACK_CHANNEL,
                    environment: params.ENVIRONMENT,
                    service: env.SERVICE_NAME,
                    message: """
                    âœ… authz-server ë°°í¬ ì„±ê³µ
                    í™˜ê²½: ${params.ENVIRONMENT}
                    ì´ë¯¸ì§€: ${env.DOCKER_REGISTRY}/${env.SERVICE_NAME}:${env.IMAGE_TAG}
                    """.stripIndent()
                )
            }
        }
        failure {
            script {
                notifySlack(
                    status: 'FAILURE',
                    channel: env.SLACK_CHANNEL,
                    environment: params.ENVIRONMENT,
                    service: env.SERVICE_NAME,
                    message: """
                    âŒ authz-server ë°°í¬ ì‹¤íŒ¨
                    ë¡œê·¸: ${env.BUILD_URL}console
                    """.stripIndent()
                )
            }
        }
        always {
            junit allowEmptyResults: true, testResults: '**/test-results/**/*.xml'
            cleanWs(
                deleteDirs: true,
                patterns: [
                    [pattern: 'node_modules', type: 'INCLUDE'],
                    [pattern: 'dist', type: 'INCLUDE']
                ]
            )
        }
    }
}
