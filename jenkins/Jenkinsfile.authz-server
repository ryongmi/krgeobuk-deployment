// authz-server ì „ìš© ë°°í¬ íŒŒì´í”„ë¼ì¸
// ê¶Œí•œ ê´€ë¦¬ ì„œë²„ì˜ ë¹Œë“œ, í…ŒìŠ¤íŠ¸, ë°°í¬ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.

@Library('krgeobuk-shared-library') _

pipeline {
    agent any

    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'prod'],
            description: 'ë°°í¬ í™˜ê²½'
        )
        string(
            name: 'GIT_BRANCH',
            defaultValue: 'dev',
            description: 'Git ë¸Œëœì¹˜'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'í…ŒìŠ¤íŠ¸ ê±´ë„ˆë›°ê¸°'
        )
        booleanParam(
            name: 'RUN_E2E_TESTS',
            defaultValue: false,
            description: 'E2E í…ŒìŠ¤íŠ¸ ì‹¤í–‰'
        )
    }

    environment {
        SERVICE_NAME = 'authz-server'
        DOCKER_REGISTRY = 'krgeobuk'
        DOCKER_CREDENTIALS_ID = 'docker-registry-credentials'

        GIT_REPO = 'https://github.com/ryongmi/authz-server.git'
        GIT_CREDENTIALS_ID = 'github-credentials'

        BUILD_TIMESTAMP = sh(script: "date +%Y%m%d-%H%M%S", returnStdout: true).trim()
        GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()

        // ì´ë¯¸ì§€ íƒœê·¸: devëŠ” latest, prodëŠ” timestamp
        IMAGE_TAG = params.ENVIRONMENT == 'dev' ? 'latest' : "${BUILD_TIMESTAMP}-${GIT_COMMIT_SHORT}"

        K8S_NAMESPACE = params.ENVIRONMENT == 'prod' ? 'krgeobuk-prod' : 'krgeobuk-dev'
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '30'))
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
    }

    stages {
        stage('ğŸ“‹ Prepare') {
            steps {
                script {
                    echo """
                    =========================================
                    authz-server ë°°í¬ íŒŒì´í”„ë¼ì¸
                    =========================================
                    í™˜ê²½: ${params.ENVIRONMENT}
                    ë¸Œëœì¹˜: ${params.GIT_BRANCH}
                    ë„¤ì„ìŠ¤í˜ì´ìŠ¤: ${env.K8S_NAMESPACE}
                    ì´ë¯¸ì§€ íƒœê·¸: ${env.IMAGE_TAG}
                    =========================================
                    """
                }
            }
        }

        stage('ğŸ” Checkout') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${params.GIT_BRANCH}"]],
                    userRemoteConfigs: [[
                        url: env.GIT_REPO,
                        credentialsId: env.GIT_CREDENTIALS_ID
                    ]]
                ])
            }
        }

        stage('ğŸ“¦ Install Dependencies') {
            steps {
                sh 'npm ci'
            }
        }

        stage('ğŸ§ª Run Tests') {
            when {
                expression { !params.SKIP_TESTS }
            }
            parallel {
                stage('Unit Tests') {
                    steps {
                        sh 'npm run test'
                    }
                }
                stage('Lint') {
                    steps {
                        sh 'npm run lint'
                    }
                }
            }
        }

        stage('ğŸ§ª E2E Tests') {
            when {
                expression { params.RUN_E2E_TESTS }
            }
            steps {
                sh 'npm run test:e2e'
            }
        }

        stage('ğŸ—ï¸ Build') {
            steps {
                sh 'npm run build'
            }
        }

        stage('ğŸ³ Build Docker Image') {
            steps {
                script {
                    if (params.ENVIRONMENT == 'dev') {
                        // dev í™˜ê²½: ë¡œì»¬ ì´ë¯¸ì§€ ë¹Œë“œ (miniPCì—ì„œ ì‚¬ìš©)
                        echo "Building local Docker image for dev environment..."
                        sh """
                            docker build -t ${env.SERVICE_NAME}:latest .
                            echo "âœ“ Local image built: ${env.SERVICE_NAME}:latest"
                        """
                    } else {
                        // prod í™˜ê²½: Registryì— push
                        echo "Building and pushing Docker image for prod environment..."
                        buildImage(
                            serviceName: env.SERVICE_NAME,
                            imageTag: env.IMAGE_TAG,
                            dockerRegistry: env.DOCKER_REGISTRY,
                            additionalTags: ['latest']
                        )
                    }
                }
            }
        }

        stage('ğŸš€ Deploy to Kubernetes') {
            steps {
                script {
                    if (params.ENVIRONMENT == 'prod') {
                        input message: 'Production í™˜ê²½ì— ë°°í¬í•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
                              ok: 'Deploy to Production',
                              submitter: 'admin,devops'
                    }

                    deployToK8s(
                        environment: params.ENVIRONMENT,
                        service: env.SERVICE_NAME,
                        imageTag: env.IMAGE_TAG,
                        namespace: env.K8S_NAMESPACE
                    )
                }
            }
        }

        stage('âœ… Verify Deployment') {
            steps {
                sh """
                    kubectl rollout status deployment/${env.SERVICE_NAME} -n ${env.K8S_NAMESPACE} --timeout=5m
                    kubectl get pods -n ${env.K8S_NAMESPACE} -l app=${env.SERVICE_NAME}
                """
            }
        }

        stage('ğŸ” Health Check') {
            steps {
                sh """
                    kubectl wait --for=condition=ready pod -l app=${env.SERVICE_NAME} -n ${env.K8S_NAMESPACE} --timeout=300s

                    POD_NAME=\$(kubectl get pod -n ${env.K8S_NAMESPACE} -l app=${env.SERVICE_NAME} -o jsonpath='{.items[0].metadata.name}')
                    kubectl exec \$POD_NAME -n ${env.K8S_NAMESPACE} -- curl -f http://localhost:8100/health || exit 1
                """
            }
        }
    }

    post {
        success {
            script {
                notifySlack(
                    status: 'SUCCESS',
                    environment: params.ENVIRONMENT,
                    service: env.SERVICE_NAME,
                    message: """
                    âœ… authz-server ë°°í¬ ì„±ê³µ
                    í™˜ê²½: ${params.ENVIRONMENT}
                    ì´ë¯¸ì§€: ${env.DOCKER_REGISTRY}/${env.SERVICE_NAME}:${env.IMAGE_TAG}
                    """.stripIndent()
                )
            }
        }
        failure {
            script {
                notifySlack(
                    status: 'FAILURE',
                    environment: params.ENVIRONMENT,
                    service: env.SERVICE_NAME,
                    message: """
                    âŒ authz-server ë°°í¬ ì‹¤íŒ¨
                    ë¡œê·¸: ${env.BUILD_URL}console
                    """.stripIndent()
                )
            }
        }
        always {
            junit allowEmptyResults: true, testResults: '**/test-results/**/*.xml'
            cleanWs(
                deleteDirs: true,
                patterns: [
                    [pattern: 'node_modules', type: 'INCLUDE'],
                    [pattern: 'dist', type: 'INCLUDE']
                ]
            )
        }
    }
}
