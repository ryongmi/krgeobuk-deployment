// krgeobuk ÌÜµÌï© Î∞∞Ìè¨ ÌååÏù¥ÌîÑÎùºÏù∏
// Î™®Îì† ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§Ïùò ÎπåÎìú, ÌÖåÏä§Ìä∏, Î∞∞Ìè¨Î•º Í¥ÄÎ¶¨Ìï©ÎãàÎã§.

@Library('krgeobuk-shared-library') _

pipeline {
    agent any

    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'prod'],
            description: 'Î∞∞Ìè¨ ÌôòÍ≤Ω ÏÑ†ÌÉù'
        )
        choice(
            name: 'SERVICE',
            choices: [
                'all',
                'auth-server',
                'authz-server',
                'auth-client',
                'portal-client',
                'portal-server',
                'my-pick-server',
                'my-pick-client',
                'portal-admin-client',
                'my-pick-admin-client'
            ],
            description: 'Î∞∞Ìè¨Ìï† ÏÑúÎπÑÏä§ (all = Ï†ÑÏ≤¥)'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'ÌÖåÏä§Ìä∏ Í±¥ÎÑàÎõ∞Í∏∞'
        )
        booleanParam(
            name: 'FORCE_BUILD',
            defaultValue: false,
            description: 'Î≥ÄÍ≤ΩÏÇ¨Ìï≠ ÏóÜÏñ¥ÎèÑ Í∞ïÏ†ú ÎπåÎìú'
        )
    }

    environment {
        // Docker Registry
        DOCKER_REGISTRY = 'krgeobuk'
        DOCKER_CREDENTIALS_ID = 'docker-registry-credentials'

        // Git Î¶¨Ìè¨ÏßÄÌÜ†Î¶¨
        K8S_REPO = "https://github.com/${env.GITHUB_ORG}/krgeobuk-k8s.git"
        K8S_CREDENTIALS_ID = 'github-credentials'

        // ÎπåÎìú Ï†ïÎ≥¥
        BUILD_TIMESTAMP = sh(script: "date +%Y%m%d-%H%M%S", returnStdout: true).trim()
        GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
    }

    stages {
        stage('üîç Prepare') {
            steps {
                script {
                    echo "========================================="
                    echo "krgeobuk ÌÜµÌï© Î∞∞Ìè¨ ÌååÏù¥ÌîÑÎùºÏù∏"
                    echo "========================================="
                    echo "ÌôòÍ≤Ω: ${params.ENVIRONMENT}"
                    echo "ÏÑúÎπÑÏä§: ${params.SERVICE}"
                    echo "ÎπåÎìú ÏãúÍ∞Ñ: ${env.BUILD_TIMESTAMP}"
                    echo "Git Commit: ${env.GIT_COMMIT_SHORT}"
                    echo "========================================="

                    // ÌôòÍ≤ΩÎ≥Ñ Í≥µÌÜµ ÏÑ§Ï†ï Î°úÎìú (K8S_NAMESPACE, SLACK_CHANNEL, MANUAL_APPROVAL)
                    load("jenkins/config/${params.ENVIRONMENT}.groovy")
                }
            }
        }

        stage('üèóÔ∏è Build & Test') {
            when {
                expression {
                    return params.SERVICE == 'all' ||
                           params.SERVICE in ['auth-server', 'authz-server', 'portal-server', 'my-pick-server']
                }
            }
            steps {
                script {
                    def services = params.SERVICE == 'all'
                        ? ['auth-server', 'authz-server', 'portal-server', 'my-pick-server']
                        : [params.SERVICE]

                    services.each { service ->
                        stage("Build ${service}") {
                            echo "Building ${service}..."

                            // Git ÌÅ¥Î°†
                            dir(service) {
                                git url: "https://github.com/${env.GITHUB_ORG}/${service}.git",
                                    credentialsId: env.K8S_CREDENTIALS_ID,
                                    branch: params.ENVIRONMENT == 'prod' ? 'main' : 'dev'

                                // ÏùòÏ°¥ÏÑ± ÏÑ§Ïπò
                                sh 'npm ci'

                                // ÌÖåÏä§Ìä∏ Ïã§Ìñâ (ÏòµÏÖò)
                                if (!params.SKIP_TESTS) {
                                    sh 'npm run test'
                                }

                                // ÎπåÎìú
                                sh 'npm run build'

                                // Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú
                                def imageTag = "${env.BUILD_TIMESTAMP}-${env.GIT_COMMIT_SHORT}"
                                buildImage(
                                    serviceName: service,
                                    imageTag: imageTag,
                                    dockerRegistry: env.DOCKER_REGISTRY
                                )
                            }
                        }
                    }
                }
            }
        }

        stage('üñºÔ∏è Build Frontend') {
            when {
                expression {
                    return params.SERVICE == 'all' ||
                           params.SERVICE in ['auth-client', 'portal-client', 'my-pick-client', 'portal-admin-client', 'my-pick-admin-client']
                }
            }
            steps {
                script {
                    def frontendServices = params.SERVICE == 'all'
                        ? ['auth-client', 'portal-client', 'my-pick-client', 'portal-admin-client', 'my-pick-admin-client']
                        : [params.SERVICE]

                    frontendServices.each { service ->
                        stage("Build ${service}") {
                            echo "Building ${service}..."

                            dir(service) {
                                git url: "https://github.com/${env.GITHUB_ORG}/${service}.git",
                                    credentialsId: env.K8S_CREDENTIALS_ID,
                                    branch: params.ENVIRONMENT == 'prod' ? 'main' : 'dev'

                                sh 'npm ci'

                                if (!params.SKIP_TESTS) {
                                    sh 'npm run lint'
                                }

                                sh 'npm run build'

                                def imageTag = "${env.BUILD_TIMESTAMP}-${env.GIT_COMMIT_SHORT}"
                                buildImage(
                                    serviceName: service,
                                    imageTag: imageTag,
                                    dockerRegistry: env.DOCKER_REGISTRY
                                )
                            }
                        }
                    }
                }
            }
        }

        stage('üì¶ Deploy to Kubernetes') {
            steps {
                script {
                    // K8s Î¶¨Ìè¨ÏßÄÌÜ†Î¶¨ ÌÅ¥Î°†
                    dir('krgeobuk-k8s') {
                        git url: env.K8S_REPO,
                            credentialsId: env.K8S_CREDENTIALS_ID,
                            branch: 'main'

                        // Î∞∞Ìè¨ Ïã§Ìñâ
                        if (params.ENVIRONMENT == 'prod') {
                            // ProductionÏùÄ ÏàòÎèô ÏäπÏù∏ ÌïÑÏöî
                            input message: 'Production Î∞∞Ìè¨Î•º ÏßÑÌñâÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
                                  ok: 'Deploy'
                        }

                        deployToK8s(
                            environment: params.ENVIRONMENT,
                            service: params.SERVICE,
                            imageTag: "${env.BUILD_TIMESTAMP}-${env.GIT_COMMIT_SHORT}"
                        )
                    }
                }
            }
        }

        stage('üîç Smoke Test') {
            steps {
                script {
                    echo "Running smoke tests..."
                    sh "./scripts/smoke-test.sh ${params.ENVIRONMENT}"
                }
            }
        }
    }

    post {
        success {
            script {
                notifySlack(
                    status: 'SUCCESS',
                    environment: params.ENVIRONMENT,
                    service: params.SERVICE,
                    message: "Î∞∞Ìè¨ ÏÑ±Í≥µ: ${params.SERVICE} ‚Üí ${params.ENVIRONMENT}"
                )
            }
        }
        failure {
            script {
                notifySlack(
                    status: 'FAILURE',
                    environment: params.ENVIRONMENT,
                    service: params.SERVICE,
                    message: "Î∞∞Ìè¨ Ïã§Ìå®: ${params.SERVICE} ‚Üí ${params.ENVIRONMENT}"
                )
            }
        }
        always {
            cleanWs()
        }
    }
}
